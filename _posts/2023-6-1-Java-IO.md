---
layout: post
read_time: true
show_date: true
title:  Java IO库详解
date:   2023-6-1 10:00:20 -0600
description: 详细记录Java IO/NIO的使用和原理
img: posts/java-io/cover.png 
tags: [java, IO, NIO, 并发]
author: 尹康
github: yinkang-sh/yinkang-blog
mathjax: yes
---

# Java IO库体系

源代码目录：`src/java.base/share/java/io`

## 1. `java.io`的设计宗旨和使用场景

### 1.1设计宗旨

`java.io`设计目的是为了提供一个**方便，一致，可移植和高级别的API**用来处理不同类型的**I/O操作**。具体来说就是

1. 方便性：`java.io`提供了简单易用的API，使开发者能轻松地进行文件和流的操作读写，不必在乎底层的I/O细节。
2. 一致性：采用一致的模式和类层次结构，使开发者能够使用类似的方法来处理不同类型的I/O操作，如字节流和字符流。
3. 可移植性：`java.io`的类和方法被设计称可跨平台的，因此可以在不同的操作系统上运行，而无需修改代码。
4. 高级别API：该包提供了高级别的抽象，如缓冲，对象序列化，字符编码等功能。使开发者能更轻松地处理复杂的I/O操作。

---

为了更加方便我们整体上把握`java.io`的情况，下面将介绍该包设计中的一致性体现：

1. **字节流和字符流的一致性：** 为字节流和字符流设计了相同类型的抽象类如字节流的`InputStream, OutputStream`，字符流的`Reader, Writer`。同时基于这些抽象类后续有针对不同场景的**具体实现**如文件流，管道流等，同时还有一些更加**具体业务的装饰器类**如过滤流等。
2. **异常的一致性：** 多部份的方法会抛出相似的异常，比如`IOException`
3. **标准化的方法：** 如`close(), read(), write()`等。

### 1.2 使用场景

首先值得注意的是，`java.io`主要是针对单线程模型I/O操作所设计的，更多更现代的并发IO可以使用`java.nio`包。因此`java.io`包中的很多操作都是线程不安全的，当然也可以使用java 的同步机制来进行限制。但是并不是最优的性能。总结如下：

1. `java.io`的设计是基于单线程模型。直接在并发环境中使用可能导致数据不一致。
2. 高并发环境中使用`java.io`可能会导致比较大的性能损耗。
3. 适用低并发和简单场景。对于高并发和更加复杂的IO操作，简易使用`java.nio`

下面介绍`java.io`具体提供了那些功能以及对应的类。

1. **文件操作**
2. **字节流/字符流操作**
3. **对象序列化和反序列化**
4. **基本数据类型和字符串的格式化读写**
5.  **流的过滤和装饰**
6. **线程之间管道通信**

## 2. 文件操作（File）

涉及到的类是`jvaa.io.File`和文件流相关的类`java.io.File*`。具体使用方式查询文档即可。

## 3. IO流

下面只是介绍相关的类和IO流的原理。具体API的使用方式查询文档即可。

### 3.1 java.io流的原理

IO流的基本原理是将数据从一个源传输到一个数据目标中。IO流通常涉及到以下几个部分：

1. **数据源（Source）**：这是数据的来源，可以是文件，网络连接，键盘输入等。数据源提供了数据的输入，同时数据源本质上也是另一个流的终点。
2. **数据目标（Destination）**：这是数据的目的地，可以是文件，网络连接，屏幕输出等。数据目标是接受数据的输出，本质上可以是另一个流的起点。
3. **数据流（Stream）**：数据流是数据传输的通道。它负责将数据从数据源传输到数据目标。数据流可以是字节流或者字符流。
4. **缓冲区（Buffer）**：缓冲区是在传输过程中的临时存储区域。它可以提高数据的传输性能，因为它允许数据在一次传输中一块一块地移动，而不是以字节或者字符为单位进行传输。缓冲区可以大幅减少底层的IO读写操作，从而提高效率。一般作为外部设备如硬盘之间的缓冲。

IO流的一般工作顺序是：

1. **打开数据源和数据目标**：如程序打开要读取的文件或者建立网络链接，并打开要读写的文件或目录。
2. **创建数据流**：程序创建合适的输入流或者输出流，用于从数据源读取数据并且写入数据目标。
3. **数据传输**：程序使用数据流来传输数据，数据从数据源流入输入流，并从输入流传输到输出流，最后写入数据目标。一般从输入流到输出流中间的过程是在内存中完成的。
4. **关闭流和资源**：在完成数据传输后，程序关闭输入和输出流以释放资源。关闭流之前还应该确保数据被刷新到了数据目标。
5. **处理异常**：在上述过程中可能产生异常，程序需要适当处理这些异常，以确保程序的稳定性。

IO流的劣势：

1. 性能开销增加：IO操作可能引用额外的性能开销，特别是在大数据量的情况下，频繁的底层IO操作（可以通过适当引入缓冲区缓解）。
2. 堵塞：某些IO操作是堵塞的，意味着程序将等待知道操作完成，这可能导致程序在等待期间无法执行其他任务。
3. 异常处理的代码复杂性：IO操作可能引发异常，因此必须进行异常处理，这增加了代码的复杂性。

### 3.2 缓冲区在IO流中的原理

IO流中的缓冲区是一个临时的存储区域，用于提高数据传输的性能。它通过减少实际的读写操作次数，从而减少了与底层设备或者文件的交互次数，提高了数据传输的效率。缓冲区对大型的文件和网络通信尤其有用。以下是缓冲区在IO流中如何工作：

1. **创建缓冲区：**在使用缓冲流时程序会创建一个缓冲区，缓冲区的大小和单位取决于缓冲流的构造。
2. **数据填充：**当数据从数据源中读入时，数据会首先被填充到缓冲区。这是一次性的操作，通常是将一定量的数据一次性读入缓冲区，这样就减少了底层交互的次数，也是性能提升的关键步骤。
3. **缓冲区的操作：**程序可以直接从缓冲区中读取数据，而不是从数据源中读取。同样当数据需要写入数据目标时，数据可以首先写入缓冲区，然后一次性写入目标。
4. **自动刷新：**缓冲区通常有自动刷新机制，当缓冲区满了或者达到一定条件时，他会自动将缓冲区中的数据刷新到数据目标中。这可以减少实际的写操作次数，提高性能。
5. **关闭缓冲流：**当不在需要缓冲流的时候，程序应该关闭缓冲流。关闭缓冲流时，它会自动刷新缓冲区并释放资源。

### 3.3 IO能提供的功能

#### 3.3.1 文件流

与文件相关的流是

1. `FileInputStream`, `FileOutputStream` 字节输入输出流。
2. `FileReader`, `FileWriter`字符输入输出流。

实际使用中考虑到性能问题，可以使用缓冲包装类进行装饰。

#### 3.3.2 过滤流

首先过滤流是对流的一种包装类，从而提供额外的功能或者改变流的行为。`FilterInputStream, FilterOutputStream, FilterWriter, FilterReader`但是这些类一般不是直接使用的，而是使用他们的子类。基本上后续所有的功能流都是基于此的。如缓冲流，对象流，基本数据流，格式化流，数组流，回退流等。

#### 3.3.3 缓冲流

主要是通过减少底层交互的次数来提高数据传输的速率。可以通过该流的装饰提高速度，尤其对于大数据的IO行为。相关的类命名为`Buffered*`

#### 3.3.4 对象流

可以在流中进行数据的序列化和反序列化，从而达到传输对象的目的。注意使用对象流的数据对象，需要进行一定的序列化处理。如实现`Serializable `接口来定义序列化原则。

#### 3.3.5 基本数据流

可以对基本的数据类型进行读写，相关的类有`DataInputStream,DataOutputStream`。

#### 3.3.6 串联流

可以将多个输入流串联在一起从而像使用一个流一样处理。相关的类是`SequenceInputStream`。注意该类是和过滤流平级的包装类。

#### 3.3.7 格式化流

将格式化的数据写入到输出流中，它属于输出流的一个包装类。该流支持比较丰富的API，可以支持各种类型的写入方式。相关的类`PrintStream（字节流），PrintWriter(字符流)`。

#### 3.3.8 数组流

可以对数组进行读写。常见的类是`ByteArray*Stream, CharArray*`。

#### 3.3.9 管道流

支持线程之间的管道通信，`Piped*`。是和文件流平级的流。

#### 3.3.10 回退流

允许读取过程撤销。`Pushback*`

还有很多其他类型的流，但是大体上分成两种，一种是针对不同数据源和数据目标的流。第二种是在一般流的基础上提供额外功能或者改变其行为的包装流。具体实践中应该详细甄别数据源，数据目标和业务要求进行选择或者自行拓展实现。





